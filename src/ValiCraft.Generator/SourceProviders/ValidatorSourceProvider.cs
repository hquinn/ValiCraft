using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using ValiCraft.Generator.Models;
using ValiCraft.Generator.RuleChains;
using ValiCraft.Generator.RuleChains.Context;
using ValiCraft.Generator.Types;

namespace ValiCraft.Generator.SourceProviders;

public static class ValidatorSourceProvider
{
    public static void EmitSourceCode(
        ImmutableArray<ProviderResult<Validator>> validatorResults,
        SourceProductionContext context)
    {
        foreach (var validatorResult in validatorResults)
        {
            if (HasReportedDiagnostics(validatorResult, context))
            {
                continue;
            }

            var sourceCode = GenerateSourceCode(validatorResult.Value!);

            context.AddSource($"{validatorResult.Value!.Class.Namespace}.{validatorResult.Value!.Class.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static bool HasReportedDiagnostics(
        ProviderResult<Validator> validatorResult,
        SourceProductionContext context)
    {
        if (validatorResult.Diagnostics is not { Count: > 0 })
        {
            return false;
        }
        
        foreach (var diagnostic in validatorResult.Diagnostics)
        {
            context.ReportDiagnostic(diagnostic.CreateDiagnostic());
        }

        return true;
    }

    private static string GenerateSourceCode(Validator validator)
    {
        var usingDirectivesBuilder = new StringBuilder();

        foreach (var usingDirective in validator.UsingDirectives)
        {
            usingDirectivesBuilder.AppendLine(usingDirective);
        }

        if (validator.IsAsync)
        {
            return $$"""
                     // <auto-generated />
                     #nullable enable

                     {{usingDirectivesBuilder}}
                     namespace {{validator.Class.Namespace}}
                     {
                         /// <summary>
                         /// Generated async validator for <see cref="{{validator.RequestTypeName.FullyQualifiedName}}"/>.
                         /// </summary>
                         {{validator.Class.Modifiers}} class {{validator.Class.Name}} : global::{{KnownNames.Interfaces.GetValidatorInterface(validator.IsAsync)}}<{{validator.RequestTypeName.FullyQualifiedName}}>
                         {
                             /// <inheritdoc />
                             public async global::System.Threading.Tasks.Task<global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>> {{KnownNames.Methods.GetValidateMethod(validator.IsAsync)}}({{validator.RequestTypeName.FullyQualifiedName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                             {
                                 var errors = await RunValidationLogicAsync(request, null, cancellationToken);

                                 return errors is not null
                                     ? global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Failure(new global::{{KnownNames.Types.ValidationErrors}}
                                     {
                                         Code = "{{validator.RequestTypeName.Name}}Errors",
                                         Message = "One or more validation errors occurred.",
                                         Severity = global::{{KnownNames.Enums.ErrorSeverity}}.Error,
                                         Metadata = new global::System.Collections.Generic.Dictionary<string, object?>
                                         {
                                             { "RequestType", "{{validator.RequestTypeName.Name}}" },
                                             { "ValidationCount", errors.Count }
                                         },
                                         Errors = errors
                                     })
                                     : global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Success(request);
                             }

                             /// <inheritdoc />
                             public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName.FullyQualifiedName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                             {
                                 return await RunValidationLogicAsync(request, null, cancellationToken) ?? [];
                             }

                             /// <inheritdoc />
                             [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                             public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken = default)
                             {
                                 return await RunValidationLogicAsync(request, inheritedTargetPath, cancellationToken) ?? [];
                             }

                             private async global::System.Threading.Tasks.Task<global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>?> RunValidationLogicAsync({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken)
                             {
                                 global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? errors = null;

                     {{GenerateCodeForRuleChains(validator.RuleChains)}}

                                 return errors;
                             }
                         }
                     }
                     """;
        }

        return $$"""
                 // <auto-generated />
                 #nullable enable

                 {{usingDirectivesBuilder}}
                 namespace {{validator.Class.Namespace}}
                 {
                     /// <summary>
                     /// Generated validator for <see cref="{{validator.RequestTypeName.FullyQualifiedName}}"/>.
                     /// </summary>
                     {{validator.Class.Modifiers}} class {{validator.Class.Name}} : global::{{KnownNames.Interfaces.GetValidatorInterface(validator.IsAsync)}}<{{validator.RequestTypeName.FullyQualifiedName}}>
                     {
                         /// <inheritdoc />
                         public global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}> {{KnownNames.Methods.GetValidateMethod(validator.IsAsync)}}({{validator.RequestTypeName.FullyQualifiedName}} request)
                         {
                             var errors = RunValidationLogic(request, null);

                             return errors is not null
                                 ? global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Failure(new global::{{KnownNames.Types.ValidationErrors}}
                                 {
                                     Code = "{{validator.RequestTypeName.Name}}Errors",
                                     Message = "One or more validation errors occurred.",
                                     Severity = global::{{KnownNames.Enums.ErrorSeverity}}.Error,
                                     Metadata = new global::System.Collections.Generic.Dictionary<string, object?>
                                     {
                                         { "RequestType", "{{validator.RequestTypeName.Name}}" },
                                         { "ValidationCount", errors.Count }
                                     },
                                     Errors = errors
                                 })
                                 : global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Success(request);
                         }

                         /// <inheritdoc />
                         public global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}> ValidateToList({{validator.RequestTypeName.FullyQualifiedName}} request)
                         {
                             return RunValidationLogic(request, null) ?? [];
                         }

                         /// <inheritdoc />
                         [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                         public global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}> ValidateToList({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath)
                         {
                             return RunValidationLogic(request, inheritedTargetPath) ?? [];
                         }

                         private global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? RunValidationLogic({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath)
                         {
                             global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? errors = null;

                 {{GenerateCodeForRuleChains(validator.RuleChains)}}

                             return errors;
                         }
                     }
                 }
                 """;
    }

    private static string GenerateCodeForRuleChains(EquatableArray<RuleChain> ruleChains)
    {
        var ruleChainsCode = new List<string>();
        var context = new RuleChainContext(ruleChains.Sum(rc => rc.NumberOfRules));
        
        foreach (var ruleChain in ruleChains)
        {
            ruleChainsCode.Add(ruleChain.GenerateCode(context));
        }
        
        return string.Join("\r\n\r\n", ruleChainsCode);
    }
}