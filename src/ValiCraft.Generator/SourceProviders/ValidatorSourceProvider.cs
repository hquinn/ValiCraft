using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using ValiCraft.Generator.Concepts;
using ValiCraft.Generator.Models;
using ValiCraft.Generator.RuleChains;
using ValiCraft.Generator.RuleChains.Context;
using ValiCraft.Generator.Types;

namespace ValiCraft.Generator.SourceProviders;

public static class ValidatorSourceProvider
{
    public static void EmitSourceCode(
        ImmutableArray<ProviderResult<Validator>> validatorResults,
        SourceProductionContext context)
    {
        foreach (var validatorResult in validatorResults)
        {
            if (HasReportedDiagnostics(validatorResult, context))
            {
                continue;
            }

            var sourceCode = GenerateSourceCode(validatorResult.Value!);
            var fileName = GetFileName(validatorResult.Value!);

            context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static string GetFileName(Validator validator)
    {
        var containingTypesPrefix = string.Join(".", validator.Class.ContainingTypes.Select(ct => ct.Name));
        
        if (!string.IsNullOrEmpty(containingTypesPrefix))
        {
            return $"{validator.Class.Namespace}.{containingTypesPrefix}.{validator.Class.Name}.g.cs";
        }
        
        return $"{validator.Class.Namespace}.{validator.Class.Name}.g.cs";
    }

    private static bool HasReportedDiagnostics(
        ProviderResult<Validator> validatorResult,
        SourceProductionContext context)
    {
        if (validatorResult.Diagnostics is not { Count: > 0 })
        {
            return false;
        }
        
        foreach (var diagnostic in validatorResult.Diagnostics)
        {
            context.ReportDiagnostic(diagnostic.CreateDiagnostic());
        }

        return true;
    }

    private static string GenerateSourceCode(Validator validator)
    {
        var usingDirectivesBuilder = new StringBuilder();

        foreach (var usingDirective in validator.UsingDirectives)
        {
            usingDirectivesBuilder.AppendLine(usingDirective);
        }

        var validatorClassContent = GenerateValidatorClassContent(validator);
        var wrappedContent = WrapInContainingTypes(validator.Class.ContainingTypes, validatorClassContent);

        return $$"""
                 // <auto-generated />
                 #nullable enable

                 {{usingDirectivesBuilder}}
                 namespace {{validator.Class.Namespace}}
                 {
                 {{wrappedContent}}
                 }
                 """;
    }

    private static string WrapInContainingTypes(EquatableArray<ContainingTypeInfo> containingTypes, string innerContent)
    {
        if (containingTypes.Count == 0)
        {
            return innerContent;
        }

        var result = innerContent;
        
        // Start from innermost and wrap outward (reverse order since containingTypes is outermost-first)
        for (var i = containingTypes.Count - 1; i >= 0; i--)
        {
            var containingType = containingTypes[i];
            var indentedContent = IndentContent(result, "    ");
            result = $"    {containingType.Modifiers} class {containingType.Name}\n    {{\n{indentedContent}\n    }}";
        }

        return result;
    }

    private static string IndentContent(string content, string indent)
    {
        var lines = content.Split('\n');
        var indentedLines = lines.Select(line => string.IsNullOrWhiteSpace(line) ? line : indent + line);
        return string.Join("\n", indentedLines);
    }

    private static string GenerateValidatorClassContent(Validator validator)
    {
        if (validator.IsAsync)
        {
            return $$"""
                    /// <summary>
                    /// Generated async validator for <see cref="{{validator.RequestTypeName.FullyQualifiedName}}"/>.
                    /// </summary>
                    {{validator.Class.Modifiers}} class {{validator.Class.Name}} : global::{{KnownNames.Interfaces.GetValidatorInterface(validator.IsAsync)}}<{{validator.RequestTypeName.FullyQualifiedName}}>
                    {
                        /// <inheritdoc />
                        public async global::System.Threading.Tasks.Task<global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>> {{KnownNames.Methods.GetValidateMethod(validator.IsAsync)}}({{validator.RequestTypeName.FullyQualifiedName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                        {
                            var errors = await RunValidationLogicAsync(request, null, cancellationToken);

                            return errors is not null
                                ? global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Failure(new global::{{KnownNames.Types.ValidationErrors}}
                                {
                                    Code = "{{validator.RequestTypeName.Name}}Errors",
                                    Message = "One or more validation errors occurred.",
                                    Severity = global::{{KnownNames.Enums.ErrorSeverity}}.Error,
                                    Metadata = new global::System.Collections.Generic.Dictionary<string, object?>
                                    {
                                        { "RequestType", "{{validator.RequestTypeName.Name}}" },
                                        { "ValidationCount", errors.Count }
                                    },
                                    Errors = errors
                                })
                                : global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Success(request);
                        }

                        /// <inheritdoc />
                        public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName.FullyQualifiedName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                        {
                            return await RunValidationLogicAsync(request, null, cancellationToken) ?? [];
                        }

                        /// <inheritdoc />
                        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                        public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken = default)
                        {
                            return await RunValidationLogicAsync(request, inheritedTargetPath, cancellationToken) ?? [];
                        }

                        private async global::System.Threading.Tasks.Task<global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>?> RunValidationLogicAsync({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken)
                        {
                            global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? errors = null;

                {{GenerateCodeForRuleChains(validator.RuleChains)}}

                            return errors;
                        }
                    }
                """;
        }

        return $$"""
                /// <summary>
                /// Generated validator for <see cref="{{validator.RequestTypeName.FullyQualifiedName}}"/>.
                /// </summary>
                {{validator.Class.Modifiers}} class {{validator.Class.Name}} : global::{{KnownNames.Interfaces.GetValidatorInterface(validator.IsAsync)}}<{{validator.RequestTypeName.FullyQualifiedName}}>
                {
                    /// <inheritdoc />
                    public global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}> {{KnownNames.Methods.GetValidateMethod(validator.IsAsync)}}({{validator.RequestTypeName.FullyQualifiedName}} request)
                    {
                        var errors = RunValidationLogic(request, null);

                        return errors is not null
                            ? global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Failure(new global::{{KnownNames.Types.ValidationErrors}}
                            {
                                Code = "{{validator.RequestTypeName.Name}}Errors",
                                Message = "One or more validation errors occurred.",
                                Severity = global::{{KnownNames.Enums.ErrorSeverity}}.Error,
                                Metadata = new global::System.Collections.Generic.Dictionary<string, object?>
                                {
                                    { "RequestType", "{{validator.RequestTypeName.Name}}" },
                                    { "ValidationCount", errors.Count }
                                },
                                Errors = errors
                            })
                            : global::{{KnownNames.Types.Result}}<global::{{KnownNames.Interfaces.IValidationErrors}}, {{validator.RequestTypeName.FullyQualifiedName}}>.Success(request);
                    }

                    /// <inheritdoc />
                    public global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}> ValidateToList({{validator.RequestTypeName.FullyQualifiedName}} request)
                    {
                        return RunValidationLogic(request, null) ?? [];
                    }

                    /// <inheritdoc />
                    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                    public global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}> ValidateToList({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath)
                    {
                        return RunValidationLogic(request, inheritedTargetPath) ?? [];
                    }

                    private global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? RunValidationLogic({{validator.RequestTypeName.FullyQualifiedName}} request, string? inheritedTargetPath)
                    {
                        global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? errors = null;

            {{GenerateCodeForRuleChains(validator.RuleChains)}}

                        return errors;
                    }
                }
            """;
    }

    private static string GenerateCodeForRuleChains(EquatableArray<RuleChain> ruleChains)
    {
        var ruleChainsCode = new List<string>();
        var context = new RuleChainContext(ruleChains.Sum(rc => rc.NumberOfRules));
        
        foreach (var ruleChain in ruleChains)
        {
            ruleChainsCode.Add(ruleChain.GenerateCode(context));
        }
        
        return string.Join("\r\n\r\n", ruleChainsCode);
    }
}