using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using ValiCraft.Generator.Models;
using ValiCraft.Generator.RuleChains;
using ValiCraft.Generator.RuleChains.Context;
using ValiCraft.Generator.Types;

namespace ValiCraft.Generator.SourceProviders;

public static class ValidatorSourceProvider
{
    public static void EmitSourceCode(
        bool isAsync,
        ImmutableArray<ProviderResult<ValidationRule>> validationRuleResults,
        ImmutableArray<ProviderResult<Validator>> validatorResults,
        SourceProductionContext context)
    {
        var validRules = validationRuleResults
            .Where(r => r.Value is not null)
            .Select(r => r.Value!)
            .ToArray();

        foreach (var validatorResult in validatorResults)
        {
            if (HasReportedDiagnostics(validatorResult, context) ||
                !validatorResult.Value!.TryLinkWeakSemanticRules(validRules, context, out var validator))
            {
                continue;
            }

            var sourceCode = GenerateSourceCode(isAsync, validator!);

            context.AddSource($"{validatorResult.Value!.Class.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static bool HasReportedDiagnostics(
        ProviderResult<Validator> validatorResult,
        SourceProductionContext context)
    {
        if (validatorResult.Diagnostics is not { Count: > 0 })
        {
            return false;
        }
        
        foreach (var diagnostic in validatorResult.Diagnostics)
        {
            context.ReportDiagnostic(diagnostic.CreateDiagnostic());
        }

        return true;
    }

    private static string GenerateSourceCode(bool isAsync, Validator validator)
    {
        var usingDirectivesBuilder = new StringBuilder();

        foreach (var usingDirective in validator.UsingDirectives)
        {
            usingDirectivesBuilder.AppendLine(usingDirective);
        }

        if (isAsync)
        {
            return $$"""
                     // <auto-generated />
                     #nullable enable

                     {{usingDirectivesBuilder}}
                     namespace {{validator.Class.Namespace}}
                     {
                         {{validator.Class.Modifiers}} class {{validator.Class.Name}} : global::{{KnownNames.Interfaces.GetValidatorInterface(isAsync)}}<{{validator.RequestTypeName}}>
                         {
                             public async global::System.Threading.Tasks.Task<global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>> {{KnownNames.Methods.GetValidateMethod(isAsync)}}({{validator.RequestTypeName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                             {
                                 var errors = await RunValidationLogicAsync(request, null, cancellationToken);

                                 return errors is not null
                                     ? global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>.Failure(errors)
                                     : global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>.Success(request);
                             }

                             public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                             {
                                 return await RunValidationLogicAsync(request, null, cancellationToken) ?? [];
                             }

                             [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                             public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken = default)
                             {
                                 return await RunValidationLogicAsync(request, inheritedTargetPath, cancellationToken) ?? [];
                             }

                             private async global::System.Threading.Tasks.Task<global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>>? RunValidationLogicAsync({{validator.RequestTypeName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken)
                             {
                                 global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? errors = null;

                     {{GenerateCodeForRuleChains(validator.RuleChains)}}

                                 return errors;
                             }
                         }
                     }
                     """;
        }

        return $$"""
                 // <auto-generated />
                 #nullable enable

                 {{usingDirectivesBuilder}}
                 namespace {{validator.Class.Namespace}}
                 {
                     {{validator.Class.Modifiers}} class {{validator.Class.Name}} : global::{{KnownNames.Interfaces.GetValidatorInterface(isAsync)}}<{{validator.RequestTypeName}}>
                     {
                         public global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}> {{KnownNames.Methods.GetValidateMethod(isAsync)}}({{validator.RequestTypeName}} request)
                         {
                             var errors = RunValidationLogic(request, null);

                             return errors is not null
                                 ? global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>.Failure(errors)
                                 : global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>.Success(request);
                         }

                         public global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}> ValidateToList({{validator.RequestTypeName}} request)
                         {
                             return RunValidationLogic(request, null) ?? [];
                         }

                         [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                         public global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}> ValidateToList({{validator.RequestTypeName}} request, string? inheritedTargetPath)
                         {
                             return RunValidationLogic(request, inheritedTargetPath) ?? [];
                         }

                         private global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? RunValidationLogic({{validator.RequestTypeName}} request, string? inheritedTargetPath)
                         {
                             global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? errors = null;

                 {{GenerateCodeForRuleChains(validator.RuleChains)}}

                             return errors;
                         }
                     }
                 }
                 """;
    }

    private static string GenerateCodeForRuleChains(EquatableArray<RuleChain> ruleChains)
    {
        var ruleChainsCode = new List<string>();
        var context = new RuleChainContext(ruleChains.Sum(rc => rc.NumberOfRules));
        
        foreach (var ruleChain in ruleChains)
        {
            ruleChainsCode.Add(ruleChain.GenerateCode(context));
        }
        
        return string.Join("\r\n\r\n", ruleChainsCode);
    }
}