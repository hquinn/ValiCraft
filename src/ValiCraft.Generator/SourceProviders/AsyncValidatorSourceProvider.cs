using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using ValiCraft.Generator.Models;
using ValiCraft.Generator.RuleChains;
using ValiCraft.Generator.RuleChains.Context;
using ValiCraft.Generator.Types;

namespace ValiCraft.Generator.SourceProviders;

public static class AsyncValidatorSourceProvider
{
    public static void EmitSourceCode(
        ImmutableArray<ProviderResult<AsyncValidationRule>> asyncValidationRuleResults,
        ImmutableArray<ProviderResult<ValidationRule>> validationRuleResults,
        ImmutableArray<ProviderResult<AsyncValidator>> asyncValidatorResults,
        SourceProductionContext context)
    {
        var validAsyncRules = asyncValidationRuleResults
            .Where(r => r.Value is not null)
            .Select(r => r.Value!)
            .ToArray();

        var validSyncRules = validationRuleResults
            .Where(r => r.Value is not null)
            .Select(r => r.Value!)
            .ToArray();

        foreach (var asyncValidatorResult in asyncValidatorResults)
        {
            if (HasReportedDiagnostics(asyncValidatorResult, context) ||
                !asyncValidatorResult.Value!.TryLinkWeakSemanticRules(validAsyncRules, validSyncRules, context, out var validator))
            {
                continue;
            }

            var sourceCode = GenerateSourceCode(validator!);

            context.AddSource($"{asyncValidatorResult.Value!.Class.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static bool HasReportedDiagnostics(
        ProviderResult<AsyncValidator> asyncValidatorResult,
        SourceProductionContext context)
    {
        if (asyncValidatorResult.Diagnostics is not { Count: > 0 })
        {
            return false;
        }
        
        foreach (var diagnostic in asyncValidatorResult.Diagnostics)
        {
            context.ReportDiagnostic(diagnostic.CreateDiagnostic());
        }

        return true;
    }

    private static string GenerateSourceCode(AsyncValidator validator)
    {
        var usingDirectivesBuilder = new StringBuilder();

        foreach (var usingDirective in validator.UsingDirectives)
        {
            usingDirectivesBuilder.AppendLine(usingDirective);
        }
        
        return $$"""
                 // <auto-generated />
                 #nullable enable

                 {{usingDirectivesBuilder}}
                 namespace {{validator.Class.Namespace}}
                 {
                     {{validator.Class.Modifiers}} class {{validator.Class.Name}} : global::{{KnownNames.Interfaces.IAsyncValidator}}<{{validator.RequestTypeName}}>
                     {
                         public async global::System.Threading.Tasks.Task<global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>> ValidateAsync({{validator.RequestTypeName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                         {
                             var errors = await RunValidationLogicAsync(request, null, cancellationToken).ConfigureAwait(false);

                             return errors is not null
                                 ? global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>.Failure(errors)
                                 : global::{{KnownNames.Types.Result}}<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>, {{validator.RequestTypeName}}>.Success(request);
                         }

                         public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName}} request, global::System.Threading.CancellationToken cancellationToken = default)
                         {
                             return await RunValidationLogicAsync(request, null, cancellationToken).ConfigureAwait(false) ?? [];
                         }

                         [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                         public async global::System.Threading.Tasks.Task<global::System.Collections.Generic.IReadOnlyList<global::{{KnownNames.Interfaces.IValidationError}}>> ValidateToListAsync({{validator.RequestTypeName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken = default)
                         {
                             return await RunValidationLogicAsync(request, inheritedTargetPath, cancellationToken).ConfigureAwait(false) ?? [];
                         }

                         private async global::System.Threading.Tasks.Task<global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>?> RunValidationLogicAsync({{validator.RequestTypeName}} request, string? inheritedTargetPath, global::System.Threading.CancellationToken cancellationToken)
                         {
                             global::System.Collections.Generic.List<global::{{KnownNames.Interfaces.IValidationError}}>? errors = null;

                 {{GenerateCodeForRuleChains(validator.RuleChains)}}

                             return errors;
                         }
                     }
                 }
                 """;
    }

    private static string GenerateCodeForRuleChains(EquatableArray<RuleChain> ruleChains)
    {
        var ruleChainsCode = new List<string>(ruleChains.Count);
        var context = new RuleChainContext(ruleChains.Sum(rc => rc.NumberOfRules));
        
        foreach (var ruleChain in ruleChains)
        {
            ruleChainsCode.Add(ruleChain.GenerateCode(context));
            // Note: Async rules will be handled during code generation
            // For now, this generates sync code - we'll add async support incrementally
        }
        
        return string.Join("\r\n\r\n", ruleChainsCode);
    }
}
