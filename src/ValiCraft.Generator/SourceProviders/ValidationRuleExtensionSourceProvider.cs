using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using ValiCraft.Generator.Models;
using ValiCraft.Generator.Types;

namespace ValiCraft.Generator.SourceProviders;

public static class ValidationRuleExtensionSourceProvider
{
    public static void EmitSourceCode(
        ImmutableArray<ProviderResult<ValidationRule>> validationRuleResults,
        SourceProductionContext context)
    {
        foreach (var validationRuleResult in validationRuleResults)
        {
            if (validationRuleResult.Diagnostics is { Count: > 0 })
            {
                foreach (var diagnostic in validationRuleResult.Diagnostics)
                {
                    context.ReportDiagnostic(diagnostic.CreateDiagnostic());
                }

                continue;
            }

            var validationRule = validationRuleResult.Value!;
            var mapToValidationRuleData = validationRule.GetMapToValidationRuleData();

            var attributesBuilder = new StringBuilder();

            if (validationRule.DefaultMessage is not null)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.DefaultMessage}({validationRule.DefaultMessage})]
                                              
                                          """);
            }

            foreach (var rulePlaceholder in validationRule.RulePlaceholders)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.RulePlaceholder}("{rulePlaceholder.PlaceholderName}", "{rulePlaceholder.ParameterName}")]
                                              
                                          """);
            }

            var sourceCode = $$"""
                               // <auto-generated />
                               #nullable enable

                               namespace {{validationRule.Class.Namespace}}
                               {
                                   {{attributesBuilder}}{{validationRule.Class.Accessibility}} static class {{validationRule.Class.Name}}Extensions
                                   {
                                       [global::{{KnownNames.Attributes.MapToValidationRule}}(typeof({{mapToValidationRuleData.FullyQualifiedUnboundedName}}), "{{mapToValidationRuleData.ValidationRuleGenericFormat}}")]
                                       {{validationRule.Class.Accessibility}} static global::{{KnownNames.Interfaces.IValidationRuleBuilderType}}<TRequest, TTargetType> {{validationRule.NameForExtensionMethod}}<{{validationRule.GetGenericArgumentsForExtensionMethod()}}>(
                                           {{GetMethodParameters(validationRule)}}) {{GetFullWhereClause(validationRule)}}
                                           => throw new global::System.NotImplementedException("Never gets called");
                                   }
                               }
                               """;

            context.AddSource($"{validationRule.Class.Name}Extensions.g.cs",
                SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static string GetFullWhereClause(ValidationRule validationRule)
    {
        var clauses = new List<string> { "where TRequest : class" };

        // Get all the constraint clauses we discovered from the rule's generic parameters.
        var additionalClauses = validationRule.Class.GenericParameters
            .Select(p => (p.InheritedPositions, p.Constraints))
            .Where(c => c.Constraints is not null)
            .Select(x =>
            {
                // If it's the first parameter, then we know that it's TTargetType
                if (x.InheritedPositions.Contains(0))
                {
                    return (x.Constraints! with { Type = "TTargetType" }).ToString();
                }

                return x.Constraints!.ToString();
            });

        clauses.AddRange(additionalClauses);

        return string.Join(" ", clauses);
    }

    private static string GetMethodParameters(ValidationRule validationRule)
    {
        return validationRule.GetParametersForExtensionMethod(
            $"this global::{KnownNames.Interfaces.IBuilderType}<TRequest, TTargetType> builder");
    }
}