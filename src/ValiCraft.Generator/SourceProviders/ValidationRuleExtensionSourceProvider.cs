using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using ValiCraft.Generator.Models;
using ValiCraft.Generator.Types;

namespace ValiCraft.Generator.SourceProviders;

public static class ValidationRuleExtensionSourceProvider
{
    public static void EmitSourceCode(
        ImmutableArray<ProviderResult<ValidationRule>> validationRuleResults,
        SourceProductionContext context)
    {
        foreach (var validationRuleResult in validationRuleResults)
        {
            if (validationRuleResult.Diagnostics is { Count: > 0 })
            {
                foreach (var diagnostic in validationRuleResult.Diagnostics)
                {
                    context.ReportDiagnostic(diagnostic.CreateDiagnostic());
                }

                continue;
            }

            var validationRule = validationRuleResult.Value!;
            var mapToValidationRuleData = validationRule.GetMapToValidationRuleData();

            var attributesBuilder = new StringBuilder();

            if (validationRule.DefaultMessage is not null)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.DefaultMessage}({validationRule.DefaultMessage})]
                                              
                                          """);
            }

            if (validationRule.DefaultErrorCode is not null)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.DefaultErrorCode}({validationRule.DefaultErrorCode})]
                                              
                                          """);
            }

            foreach (var rulePlaceholder in validationRule.RulePlaceholders)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.RulePlaceholder}("{rulePlaceholder.PlaceholderName}", "{rulePlaceholder.ParameterName}")]
                                              
                                          """);
            }

            var sourceCode = $$"""
                               // <auto-generated />
                               #nullable enable

                               namespace {{validationRule.Class.Namespace}}
                               {
                                   {{attributesBuilder}}{{validationRule.Class.Accessibility}} static class {{validationRule.Class.Name}}Extensions
                                   {
                                       [global::{{KnownNames.Attributes.MapToValidationRule}}(typeof({{mapToValidationRuleData.FullyQualifiedUnboundedName}}), "{{mapToValidationRuleData.ValidationRuleGenericFormat}}")]
                                       {{validationRule.Class.Accessibility}} static global::{{KnownNames.Interfaces.IValidationRuleBuilderType}}<TRequest, TTargetType> {{validationRule.NameForExtensionMethod}}<{{validationRule.GetGenericArgumentsForExtensionMethod()}}>(
                                           {{GetMethodParameters(validationRule, false)}}) {{GetFullWhereClause(validationRule)}}
                                           => throw new global::System.NotImplementedException("Never gets called");

                                       [global::{{KnownNames.Attributes.MapToValidationRule}}(typeof({{mapToValidationRuleData.FullyQualifiedUnboundedName}}), "{{mapToValidationRuleData.ValidationRuleGenericFormat}}")]
                                       {{validationRule.Class.Accessibility}} static global::{{KnownNames.Interfaces.IAsyncValidationRuleBuilderType}}<TRequest, TTargetType> {{validationRule.NameForExtensionMethod}}<{{validationRule.GetGenericArgumentsForExtensionMethod()}}>(
                                           {{GetMethodParameters(validationRule, true)}}) {{GetFullWhereClause(validationRule)}}
                                           => throw new global::System.NotImplementedException("Never gets called");
                                   }
                               }
                               """;

            context.AddSource($"{validationRule.Class.Name}Extensions.g.cs",
                SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static string GetFullWhereClause(ValidationRule validationRule)
    {
        var clauses = new List<string> { "where TRequest : class" };

        // Get constraint clauses only for type parameters that are included in the extension method
        var additionalClauses = validationRule.GetExtensionMethodGenericParameters()
            .Where(p => p.Constraints is not null)
            .Select(p =>
            {
                // If it's TTargetType, we need to substitute the original parameter name
                if (p.IsTargetType)
                {
                    // Find the original name by looking for a parameter that maps to TTargetType
                    var originalName = validationRule.Class.GenericParameters
                        .FirstOrDefault(gp => gp.InheritedPositions.Contains(0))?.Type.FormattedTypeName;
                    
                    if (originalName is not null)
                    {
                        return p.Constraints!.WithSubstitutedTypeName(originalName, "TTargetType").ToString();
                    }
                }

                return p.Constraints!.ToString();
            });

        clauses.AddRange(additionalClauses);

        return string.Join(" ", clauses);
    }

    private static string GetMethodParameters(ValidationRule validationRule, bool isAsync)
    {
        var builderType = isAsync ? KnownNames.Interfaces.IAsyncBuilderType : KnownNames.Interfaces.IBuilderType;
        return validationRule.GetParametersForExtensionMethod(
            $"this global::{builderType}<TRequest, TTargetType> builder");
    }
}