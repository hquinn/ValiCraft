using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using ValiCraft.Generator.Concepts;
using ValiCraft.Generator.Models;
using ValiCraft.Generator.Types;

namespace ValiCraft.Generator.SourceProviders;

public static class AsyncValidationRuleExtensionSourceProvider
{
    public static void EmitSourceCode(
        ImmutableArray<ProviderResult<AsyncValidationRule>> asyncValidationRuleResults,
        SourceProductionContext context)
    {
        foreach (var asyncValidationRuleResult in asyncValidationRuleResults)
        {
            if (asyncValidationRuleResult.Diagnostics is { Count: > 0 })
            {
                foreach (var diagnostic in asyncValidationRuleResult.Diagnostics)
                {
                    context.ReportDiagnostic(diagnostic.CreateDiagnostic());
                }

                continue;
            }

            var asyncValidationRule = asyncValidationRuleResult.Value!;
            var mapToValidationRuleData = asyncValidationRule.GetMapToValidationRuleData();

            var attributesBuilder = new StringBuilder();

            if (asyncValidationRule.DefaultMessage is not null)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.DefaultMessage}({asyncValidationRule.DefaultMessage})]
                                              
                                          """);
            }

            if (asyncValidationRule.DefaultErrorCode is not null)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.DefaultErrorCode}({asyncValidationRule.DefaultErrorCode})]
                                              
                                          """);
            }

            foreach (var rulePlaceholder in asyncValidationRule.RulePlaceholders)
            {
                attributesBuilder.Append($"""
                                          [global::{KnownNames.Attributes.RulePlaceholder}("{rulePlaceholder.PlaceholderName}", "{rulePlaceholder.ParameterName}")]
                                              
                                          """);
            }

            var sourceCode = $$"""
                               // <auto-generated />
                               #nullable enable

                               namespace {{asyncValidationRule.Class.Namespace}}
                               {
                                   {{attributesBuilder}}{{asyncValidationRule.Class.Accessibility}} static class {{asyncValidationRule.Class.Name}}Extensions
                                   {
                                       [global::{{KnownNames.Attributes.MapToValidationRule}}(typeof({{mapToValidationRuleData.FullyQualifiedUnboundedName}}), "{{mapToValidationRuleData.ValidationRuleGenericFormat}}")]
                                       {{asyncValidationRule.Class.Accessibility}} static global::{{KnownNames.Interfaces.IAsyncValidationRuleBuilderType}}<TRequest, TTargetType> {{asyncValidationRule.NameForExtensionMethod}}<{{asyncValidationRule.GetGenericArgumentsForExtensionMethod()}}>(
                                           {{GetMethodParameters(asyncValidationRule)}}) {{GetFullWhereClause(asyncValidationRule)}}
                                           => throw new global::System.NotImplementedException("Never gets called");
                                   }
                               }
                               """;

            context.AddSource($"{asyncValidationRule.Class.Name}Extensions.g.cs",
                SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static string GetFullWhereClause(AsyncValidationRule asyncValidationRule)
    {
        var clauses = new List<string> { "where TRequest : class" };

        // Get constraint clauses only for type parameters that are included in the extension method
        var additionalClauses = asyncValidationRule.GetExtensionMethodGenericParameters()
            .Where(p => p.Constraints is not null)
            .Select(p =>
            {
                // If it's TTargetType, we need to substitute the original parameter name
                if (p.IsTargetType)
                {
                    // Find the original name by looking for a parameter that maps to TTargetType
                    var originalName = asyncValidationRule.Class.GenericParameters
                        .FirstOrDefault(gp => gp.InheritedPositions.Contains(0))?.Type.FormattedTypeName;
                    
                    if (originalName is not null)
                    {
                        return p.Constraints!.WithSubstitutedTypeName(originalName, "TTargetType").ToString();
                    }
                }

                return p.Constraints!.ToString();
            });

        clauses.AddRange(additionalClauses);

        return string.Join(" ", clauses);
    }

    private static string GetMethodParameters(AsyncValidationRule asyncValidationRule)
    {
        return asyncValidationRule.GetParametersForExtensionMethod(
            $"this global::{KnownNames.Interfaces.IAsyncBuilderType}<TRequest, TTargetType> builder");
    }
}
